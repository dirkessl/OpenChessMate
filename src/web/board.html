<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Board</title>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="./css/chessboard-1.0.0.min.css">
    <script src="./scripts/jquery-4.0.0.min.js"></script>
    <script src="./scripts/chessboard-1.0.0.min.js"></script>
    <script>var exports = {};</script>
    <script src="https://unpkg.com/chess.js@1.4.0/dist/cjs/chess.js"></script>
    <script>var Chess = exports.Chess;</script>
</head>

<body>
    <!-- Audio elements for move sounds -->
    <audio id="moveSound" src="./sounds/move.mp3" preload="auto"></audio>
    <audio id="captureSound" src="./sounds/capture.mp3" preload="auto"></audio>

    <!-- Game selector overlay -->
    <div id="gameSelectorOverlay" class="settings-overlay">
        <div class="settings-popup" style="width: 400px; max-height: 85vh;">
            <h3>
                <button id="deleteToggleBtn" class="game-lib-delete-toggle" title="Delete games">üóë</button>
                <span>Game History</span>
                <button class="settings-close-btn" id="closeGameSelector">√ó</button>
            </h3>
            <div id="gameGrid" class="game-selector-grid"></div>
            <div id="deleteConfirmBar" class="delete-confirm-bar" style="display:none;">
                <span id="deleteConfirmText">Delete selected games?</span>
                <button id="deleteConfirmYes" class="delete-confirm-btn yes">Delete</button>
                <button id="deleteConfirmNo" class="delete-confirm-btn no">Cancel</button>
            </div>
            <div id="noGamesMsg" style="display:none; text-align:center; color:#aaa; padding:20px;">No games found</div>
        </div>
    </div>

    <!-- Settings popup overlay -->
    <div id="settingsPopup" class="settings-overlay">
        <div class="settings-popup">
            <h3>
                <span>‚öôÔ∏è Settings</span>
                <button class="settings-close-btn" id="closeSettings">√ó</button>
            </h3>

            <div class="settings-group">
                <label>Display</label>
                <div class="settings-row">
                    <span>Show board notation</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="settingNotation" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-group">
                <label>Sound</label>
                <div class="settings-row">
                    <span>Play move sounds</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="settingSound" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-group">
                <label>Board Colors</label>
                <div class="color-picker-group">
                    <div class="color-picker-item">
                        <input type="color" id="settingLightColor" value="#f0d9b5">
                        <span>Light</span>
                    </div>
                    <div class="color-picker-item">
                        <input type="color" id="settingDarkColor" value="#b58863">
                        <span>Dark</span>
                    </div>
                    <button id="resetColorsBtn" class="fen-btn" title="Reset to default">‚Üª</button>
                </div>
            </div>

            <div class="settings-group">
                <label>Piece Theme</label>
                <div class="piece-theme-row">
                    <select id="settingPieceTheme"></select>
                    <button id="addThemeBtn" class="fen-btn" title="Add custom theme">+</button>
                    <button id="deleteThemeBtn" class="fen-btn" title="Delete custom theme"
                        style="display:none;">‚àí</button>
                </div>
                <a id="themeUrlDisplay" class="theme-url-display" href="#" target="_blank"></a>
            </div>
        </div>
    </div>

    <div class="container" style="padding-top: 43px;">
        <!-- <h2>Chess Board</h2> -->

        <!-- Chess board wrapper -->
        <div class="board-wrapper">
            <div id="board" class="chessboard-container"></div>

            <!-- Control buttons in margin above board -->
            <div class="board-controls-left">
                <button id="flipBtn" class="board-ctrl-btn" title="Flip board">‚áÖ</button>
                <button id="focusBtn" class="board-ctrl-btn" title="Focus mode">‚õ∂</button>
            </div>
            <div class="board-controls-action-left">
                <button id="drawBtn" class="board-ctrl-btn game-action-btn" title="Offer draw">¬Ω Draw</button>
            </div>
            <div class="board-controls-center">
                <button id="navFirst" class="board-ctrl-btn nav-btn" title="First move">‚èÆ</button>
                <button id="navPrev" class="board-ctrl-btn nav-btn" title="Previous move">‚óÄ</button>
                <span id="moveCounter" class="move-counter">live</span>
                <button id="navNext" class="board-ctrl-btn nav-btn" title="Next move">‚ñ∂</button>
                <button id="navLast" class="board-ctrl-btn nav-btn" title="Last move / Live">‚è≠</button>
            </div>
            <div class="board-controls-action-right">
                <button id="resignBtn" class="board-ctrl-btn game-action-btn" title="Resign">‚öê Resign</button>
            </div>
            <div class="board-controls-right">
                <button id="gameSelectorBtn" class="board-ctrl-btn" title="Game history">‚Ü∫</button>
                <button id="settingsBtn" class="board-ctrl-btn" title="Settings">‚öô</button>
            </div>
        </div>

        <!-- Evaluation bar (hidden in edit mode and review mode) -->
        <div class="eval-bar-container" id="eval-container">
            <div id="eval-bar"></div>
            <div id="eval-text">--</div>
        </div>

        <!-- Game review panel (shown in review mode) -->
        <div id="review-panel" class="review-panel anim-panel">
            <div class="review-meta" id="reviewMeta"></div>
            <div class="review-moves" id="reviewMoves"></div>
        </div>

        <!-- Edit mode instructions (above board, hidden on interaction) -->
        <div class="status anim-panel" id="edit-instructions">Drag pieces to edit the board</div>

        <!-- FEN display/edit section (shown in edit mode) -->
        <div id="fen-section" class="config-panel anim-panel">

            <!-- Edit controls -->
            <div class="controls controls-sm game-options">
                <button id="sync-btn" class="button" style="background-color: #6c757d;">‚ü≥ Sync</button>
                <button id="start-btn" class="button" style="background-color: #17a2b8;">‚Üª Reset</button>
                <button id="clear-btn" class="button" style="background-color: #dc3545;">‚úï Clear</button>
            </div>

            <!-- Turn and Castling controls -->
            <div class="game-options">
                <div class="option-group">
                    <label>Turn</label>
                    <div class="toggle-group">
                        <button id="turn-white" class="toggle-btn active">White</button>
                        <button id="turn-black" class="toggle-btn">Black</button>
                    </div>
                </div>
                <div class="option-group">
                    <label>Castling</label>
                    <div class="castling-toggles">
                        <button id="castle-K" class="castle-btn active" title="White King-side">K</button>
                        <button id="castle-Q" class="castle-btn active" title="White Queen-side">Q</button>
                        <button id="castle-k" class="castle-btn active" title="Black King-side">k</button>
                        <button id="castle-q" class="castle-btn active" title="Black Queen-side">q</button>
                    </div>
                </div>
            </div>

            <!-- FEN input and copy/edit buttons -->
            <div class="fen-container">
                <input type="text" id="fen-input" readonly>
                <button id="fen-copy-btn" class="fen-btn" title="Copy FEN">üìã</button>
                <button id="fen-edit-btn" class="fen-btn" title="Edit FEN">‚úèÔ∏è</button>
            </div>

            <!-- Apply button to send to server -->
            <button id="apply-btn" class="button" style="background-color: #28a745; margin-bottom: 0">
                ‚úì Apply Changes
            </button>
        </div>

        <!-- Mode toggle button -->
        <button id="modeToggleBtn" class="button">Edit Board</button>

        <!-- Exit review mode button (hidden by default) -->
        <button id="exitReviewBtn" class="button" style="display:none;">View Board</button>

        <a href="./index.html" class="back-button">OpenChess Home</a>
    </div>

    <script>
        // Constants
        const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        const START_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';

        // State variables
        let board = null;
        let editMode = false;
        let currentTurn = 'w';
        let castlingRights = { K: true, Q: true, k: true, q: true };
        let enPassantSquare = '-';
        let halfmoveClock = 0;
        let fullmoveNumber = 1;
        let previousValidFen = START_POSITION;
        let isEditingFen = false;
        let updateInterval = null;
        let boardOrientation = 'white';
        let focusMode = false;
        let previousPosition = null;

        // Move history / scrubbing state (segment-based)
        // Each segment: { fen, engine, moveCount, globalOffset, span }
        let liveSegments = [];        // segments for the live game
        let moveIndex = 0;            // current global scrub position
        let totalMoves = 0;           // max global index
        let isLive = true;            // whether showing the live (latest) position
        let liveGameLoaded = false;   // whether we loaded the initial live game history

        // Game review state (segment-based)
        let reviewMode = false;       // viewing a completed game
        let reviewSegments = [];      // segments for the reviewed game
        let reviewMoveIndex = 0;
        let reviewTotalMoves = 0;
        let reviewGameMeta = null;    // metadata of the game being reviewed

        // Settings (loaded from localStorage)
        let settings = {
            showNotation: true,
            playSound: true,
            lightSquareColor: '#f0d9b5',
            darkSquareColor: '#b58863',
            pieceTheme: './pieces/{piece}.svg',
            customThemes: [],
            instructionsHidden: false
        };

        // Default piece themes
        const defaultThemes = [
            { value: './pieces/{piece}.svg', label: 'Local SVG (default)' },
            { value: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png', label: 'Wikipedia' },
            { value: 'https://chessboardjs.com/img/chesspieces/alpha/{piece}.png', label: 'Alpha' }
        ];

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('chessBoardSettings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    settings = { ...settings, ...parsed };
                } catch (e) {
                    console.log('Failed to parse settings');
                }
            }
            applySettings();
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('chessBoardSettings', JSON.stringify(settings));
            applySettings();
        }

        // Apply settings to UI
        function applySettings() {
            // Update settings UI
            $('#settingNotation').prop('checked', settings.showNotation);
            $('#settingSound').prop('checked', settings.playSound);
            $('#settingLightColor').val(settings.lightSquareColor);
            $('#settingDarkColor').val(settings.darkSquareColor);

            // Update piece theme dropdown
            updatePieceThemeDropdown();
            $('#settingPieceTheme').val(settings.pieceTheme);
            updateThemeUI();

            // Apply board colors
            applyBoardColors();
        }

        // Update piece theme dropdown with default and custom themes
        function updatePieceThemeDropdown() {
            const select = $('#settingPieceTheme');
            select.empty();

            // Add default themes
            defaultThemes.forEach(theme => {
                select.append($('<option>', { value: theme.value, text: theme.label }));
            });

            // Add custom themes
            if (settings.customThemes && settings.customThemes.length > 0) {
                settings.customThemes.forEach(theme => {
                    select.append($('<option>', { value: theme.value, text: theme.label, 'data-custom': 'true' }));
                });
            }

            updateThemeUI();
        }

        // Update theme URL display and delete button visibility
        function updateThemeUI() {
            const selectedValue = settings.pieceTheme;
            const isCustom = isCustomTheme(selectedValue);

            // Show/hide delete button
            $('#deleteThemeBtn').toggle(isCustom);

            // Update URL display with clickable link
            const urlDisplay = $('#themeUrlDisplay');
            urlDisplay.text(selectedValue);
            // Replace {piece} with wN (white knight) for preview link
            const previewUrl = selectedValue.replace('{piece}', 'wN');
            urlDisplay.attr('href', previewUrl);
        }

        // Check if a theme is custom (not in default themes)
        function isCustomTheme(themeValue) {
            return !defaultThemes.some(t => t.value === themeValue);
        }

        // Apply board colors dynamically (including notation)
        function applyBoardColors() {
            // Remove existing style if present
            $('#boardColorStyle').remove();

            // Notation text color is set via the square's color property
            // Light squares have dark text, dark squares have light text for contrast
            const style = `
                <style id="boardColorStyle">
                    .white-1e1d7 { 
                        background-color: ${settings.lightSquareColor} !important; 
                        color: ${settings.darkSquareColor} !important;
                    }
                    .black-3c85d { 
                        background-color: ${settings.darkSquareColor} !important; 
                        color: ${settings.lightSquareColor} !important;
                    }
                </style>
            `;
            $('head').append(style);
        }

        // Play sound effect
        function playMoveSound(isCapture) {
            if (!settings.playSound) return;

            const sound = isCapture ? document.getElementById('captureSound') : document.getElementById('moveSound');
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => { });
            }
        }

        // Detect if a move is a capture by comparing positions
        function detectCapture(oldPos, newPos) {
            // Count pieces in old and new positions
            const oldCount = Object.keys(oldPos || {}).length;
            const newCount = Object.keys(newPos || {}).length;
            return newCount < oldCount;
        }

        // Custom piece theme using settings
        function pieceTheme(piece) {
            return settings.pieceTheme.replace('{piece}', piece);
        }

        // ==========================================
        // Binary game file parsing (MoveHistory format)
        // ==========================================

        const GAME_HEADER_SIZE = 16;
        const FEN_MARKER = 0xFFFF;

        const RESULT_NAMES = ['In Progress', 'Checkmate', 'Stalemate', 'Draw (50-move)', 'Draw (3-fold)', 'Resignation', 'Draw (agreement)'];
        const MODE_NAMES = { 1: 'Human vs Human', 2: 'vs Stockfish' };
        const DEPTH_NAMES = { 5: 'Easy', 8: 'Medium', 11: 'Hard', 15: 'Expert' };

        function promoCodeToChar(code) {
            switch (code) {
                case 1: return 'q';
                case 2: return 'r';
                case 3: return 'b';
                case 4: return 'n';
                default: return '';
            }
        }

        function decodeMove(encoded) {
            const from = (encoded >> 10) & 0x3F;
            const to = (encoded >> 4) & 0x3F;
            const promo = encoded & 0x0F;
            const files = 'abcdefgh';
            // row 0 = rank 8, row 7 = rank 1
            const fromSq = files[from % 8] + (8 - Math.floor(from / 8));
            const toSq = files[to % 8] + (8 - Math.floor(to / 8));
            return fromSq + toSq + promoCodeToChar(promo);
        }

        // Shared helpers for binary parsing
        const sharedTextDecoder = new TextDecoder();

        function parseMoves(dataView, moveCount, startOffset) {
            const moves = [];
            let offset = startOffset;
            for (let i = 0; i < moveCount; i++) {
                moves.push(dataView.getUint16(offset, true));
                offset += 2;
            }
            return { moves, endOffset: offset };
        }

        function parseFenTable(buffer, startOffset, count) {
            const fens = [];
            const dv = new DataView(buffer);
            let offset = startOffset;
            for (let i = 0; i < count; i++) {
                if (offset >= buffer.byteLength) break;
                const len = dv.getUint8(offset);
                offset++;
                fens.push(sharedTextDecoder.decode(new Uint8Array(buffer, offset, len)));
                offset += len;
            }
            return fens;
        }

        function createSegment(fen, moveBuffer) {
            const engine = new Chess(fen);
            for (const uci of moveBuffer) {
                try { engine.move(uci); } catch (e) { console.warn('Replay failed:', uci, e); }
            }
            return { fen, engine, moveCount: engine.history().length, globalOffset: 0, span: 0 };
        }

        function parseGameHeader(dataView) {
            return {
                version: dataView.getUint8(0),
                mode: dataView.getUint8(1),
                result: dataView.getUint8(2),
                winnerColor: String.fromCharCode(dataView.getUint8(3)),
                playerColor: String.fromCharCode(dataView.getUint8(4)),
                botDepth: dataView.getUint8(5),
                moveCount: dataView.getUint16(6, true),
                fenEntryCnt: dataView.getUint16(8, true),
                lastFenOffset: dataView.getUint16(10, true),
                timestamp: dataView.getUint32(12, true)
            };
        }

        // Parse a completed game binary (header + moves + FEN table appended)
        function parseCompletedGame(buffer) {
            const dv = new DataView(buffer);
            const hdr = parseGameHeader(dv);
            const { moves, endOffset } = parseMoves(dv, hdr.moveCount, GAME_HEADER_SIZE);
            const fens = parseFenTable(buffer, endOffset, hdr.fenEntryCnt);
            return { header: hdr, moves, fens };
        }

        // Parse live game (header + moves from live.bin, FENs from live_fen.bin)
        function parseLiveGame(movesBuffer, fenBuffer) {
            const dv = new DataView(movesBuffer);
            const hdr = parseGameHeader(dv);
            const { moves } = parseMoves(dv, hdr.moveCount, GAME_HEADER_SIZE);
            const fens = (fenBuffer && fenBuffer.byteLength > 0) ? parseFenTable(fenBuffer, 0, hdr.fenEntryCnt) : [];
            return { header: hdr, moves, fens };
        }

        // Build game segments from parsed game data.
        // Each FEN marker starts a new segment with its own chess.js engine.
        function buildGameSegments(parsed) {
            const { moves, fens } = parsed;
            const segments = [];
            let fenIdx = -1;
            let currentFen = null;
            let currentMoveBuffer = [];

            for (let i = 0; i < moves.length; i++) {
                if (moves[i] === FEN_MARKER) {
                    if (currentFen !== null) {
                        segments.push(createSegment(currentFen, currentMoveBuffer));
                    }
                    fenIdx++;
                    currentFen = (fenIdx < fens.length) ? fens[fenIdx] : currentFen;
                    currentMoveBuffer = [];
                } else {
                    if (currentFen === null) currentFen = START_FEN;
                    currentMoveBuffer.push(decodeMove(moves[i]));
                }
            }

            if (currentFen !== null) {
                segments.push(createSegment(currentFen, currentMoveBuffer));
            }

            if (segments.length === 0) {
                segments.push(createSegment(START_FEN, []));
            }

            computeSegmentOffsets(segments);
            return segments;
        }

        // Compute globalOffset and span for each segment.
        // Each segment occupies: 1 (its starting FEN position) + moveCount.
        function computeSegmentOffsets(segments) {
            let offset = 0;
            for (let s = 0; s < segments.length; s++) {
                segments[s].globalOffset = offset;
                segments[s].span = 1 + segments[s].moveCount;
                offset += segments[s].span;
            }
        }

        // Get the maximum navigable global index
        function computeGlobalTotal(segments) {
            if (segments.length === 0) return 0;
            const last = segments[segments.length - 1];
            return last.globalOffset + last.moveCount;
        }

        // Resolve a global index into segment index and local move index
        function resolveGlobalIndex(segments, globalIdx) {
            for (let s = 0; s < segments.length; s++) {
                const seg = segments[s];
                const localIdx = globalIdx - seg.globalOffset;
                if (localIdx >= 0 && localIdx <= seg.moveCount) {
                    return { segmentIdx: s, localMoveIdx: localIdx, isBoardEdit: (s > 0 && localIdx === 0) };
                }
            }
            const last = segments[segments.length - 1];
            return { segmentIdx: segments.length - 1, localMoveIdx: last.moveCount, isBoardEdit: false };
        }

        // Get full FEN string at a given global index
        function getSegmentsFenAtIndex(segments, globalIdx) {
            if (!segments || segments.length === 0) return null;
            const { segmentIdx, localMoveIdx } = resolveGlobalIndex(segments, globalIdx);
            const seg = segments[segmentIdx];
            if (localMoveIdx === 0) {
                return seg.fen;
            }
            const hist = seg.engine.history({ verbose: true });
            if (localMoveIdx > hist.length) return seg.engine.fen();
            return hist[localMoveIdx - 1].after;
        }

        // ==========================================
        // Move navigation (scrubbing) ‚Äî segment-based
        // ==========================================

        function getActiveSegments() {
            return reviewMode ? reviewSegments : liveSegments;
        }

        function getActiveMoveIndex() {
            return reviewMode ? reviewMoveIndex : moveIndex;
        }

        function setActiveMoveIndex(idx) {
            if (reviewMode) reviewMoveIndex = idx;
            else moveIndex = idx;
        }

        function getActiveTotalMoves() {
            return reviewMode ? reviewTotalMoves : totalMoves;
        }

        function updateMoveCounter() {
            const idx = getActiveMoveIndex();
            const total = getActiveTotalMoves();
            const counter = $('#moveCounter');

            if (total === 0) {
                counter.text('--');
                return;
            }

            if (!reviewMode && isLive) {
                counter.text('live');
                counter.addClass('live');
            } else {
                counter.text(idx + '/' + total);
                counter.removeClass('live');
            }
        }

        function navigateToMove(idx) {
            const segments = getActiveSegments();
            if (!segments || segments.length === 0) return;

            const total = getActiveTotalMoves();
            if (idx < 0) idx = 0;
            if (idx > total) idx = total;

            setActiveMoveIndex(idx);

            if (!reviewMode) {
                isLive = (idx === total);
            }

            const fen = getSegmentsFenAtIndex(segments, idx);
            if (fen) {
                const posFen = fen.split(' ')[0];
                board.position(posFen, true);
            }

            updateMoveCounter();
            if (reviewMode) highlightReviewMove();
        }

        function navFirst() { navigateToMove(0); }
        function navPrev() { navigateToMove(getActiveMoveIndex() - 1); }
        function navNext() { navigateToMove(getActiveMoveIndex() + 1); }
        function navLast() { navigateToMove(getActiveTotalMoves()); }

        // ==========================================
        // Live game loading
        // ==========================================

        async function loadLiveGame() {
            try {
                const [movesResp, fenResp] = await Promise.all([
                    fetch('/games?id=live1'),
                    fetch('/games?id=live2')
                ]);

                if (!movesResp.ok) return false; // No live game

                const movesBuffer = await movesResp.arrayBuffer();
                const fenBuffer = fenResp.ok ? await fenResp.arrayBuffer() : new ArrayBuffer(0);

                if (movesBuffer.byteLength < GAME_HEADER_SIZE) return false;

                const parsed = parseLiveGame(movesBuffer, fenBuffer);
                liveSegments = buildGameSegments(parsed);
                totalMoves = computeGlobalTotal(liveSegments);
                moveIndex = totalMoves;
                isLive = true;
                liveGameLoaded = true;

                updateMoveCounter();
                return true;
            } catch (e) {
                console.log('Failed to load live game:', e);
                return false;
            }
        }

        // ==========================================
        // Game review mode
        // ==========================================

        function enterReviewMode(segments, meta) {
            reviewMode = true;
            reviewSegments = segments;
            reviewGameMeta = meta;
            reviewTotalMoves = computeGlobalTotal(segments);
            reviewMoveIndex = reviewTotalMoves; // Start at last position

            // Stop polling
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }

            // Hide eval bar, show review panel
            $('#eval-container').hide();
            $('#review-panel').addClass('visible');
            $('#modeToggleBtn').hide();
            $('#exitReviewBtn').show();

            // Build review panel content
            buildReviewPanel();

            // Show last position
            const fen = getSegmentsFenAtIndex(segments, reviewTotalMoves);
            if (fen) {
                board.position(fen.split(' ')[0], false);
            }

            updateMoveCounter();
            highlightReviewMove();
        }

        function exitReviewMode() {
            reviewMode = false;
            reviewSegments = [];
            reviewGameMeta = null;
            reviewMoveIndex = 0;
            reviewTotalMoves = 0;

            // Show eval bar, hide review panel
            $('#eval-container').show();
            $('#review-panel').removeClass('visible');
            $('#modeToggleBtn').show();
            $('#exitReviewBtn').hide();

            // Restore live position
            if (liveSegments.length > 0 && liveGameLoaded) {
                const fen = getSegmentsFenAtIndex(liveSegments, totalMoves);
                if (fen) {
                    board.position(fen.split(' ')[0], false);
                }
                moveIndex = totalMoves;
                isLive = true;
            }

            updateMoveCounter();
            startPolling();
        }

        function buildReviewPanel() {
            const meta = reviewGameMeta;
            const segments = reviewSegments;
            if (!meta || !segments || segments.length === 0) return;

            // Build metadata display (same layout as game card)
            let metaHtml = '<div class=\"review-meta-info\">';
            const date = formatDate(meta.timestamp);
            const result = RESULT_NAMES[meta.result] || 'Unknown';
            const winner = formatWinner(meta.winnerColor, meta.result);
            const opponent = formatOpponent(meta);

            metaHtml += '<span class=\"meta-date\">' + date + '</span>';
            metaHtml += '<span class=\"meta-mode\">' + opponent + '</span>';
            metaHtml += '<span class=\"meta-result\">' + winner + ' \u2014 ' + result + '</span>';
            metaHtml += '</div>';

            $('#reviewMeta').html(metaHtml);

            // Build move list with segments
            let movesHtml = '';

            for (let s = 0; s < segments.length; s++) {
                const seg = segments[s];
                const hist = seg.engine.history({ verbose: true });

                // Board Edit header (skip segment 0 ‚Äî it's the game start)
                if (s > 0) {
                    const editGlobalIdx = seg.globalOffset;
                    movesHtml += '<div class="board-edit-marker" data-gidx="' + editGlobalIdx + '">\u270f\ufe0f Board Edit #' + s + '</div>';
                }

                if (hist.length === 0) continue;

                // Determine starting turn and fullmove number from segment FEN
                const fenParts = seg.fen.split(' ');
                const startTurn = fenParts[1] || 'w';
                const startFullmove = parseInt(fenParts[5]) || 1;

                movesHtml += '<div class="pgn-segment">';

                let moveNum = startFullmove;
                let isWhiteTurn = (startTurn === 'w');

                for (let m = 0; m < hist.length; m++) {
                    const globalIdx = seg.globalOffset + 1 + m;

                    if (isWhiteTurn) {
                        // White move ‚Äî start a new row
                        movesHtml += '<span class="pgn-move-num">' + moveNum + '.</span>';
                        movesHtml += '<span class="pgn-move" data-gidx="' + globalIdx + '">' + hist[m].san + '</span>';
                        isWhiteTurn = false;
                    } else {
                        if (m === 0) {
                            // Black starts this segment ‚Äî show number + empty white cell
                            movesHtml += '<span class="pgn-move-num">' + moveNum + '.</span>';
                            movesHtml += '<span class="pgn-move-empty"></span>';
                        }
                        movesHtml += '<span class="pgn-move" data-gidx="' + globalIdx + '">' + hist[m].san + '</span>';
                        isWhiteTurn = true;
                        moveNum++;
                    }
                }

                movesHtml += '</div>';
            }

            // Add result
            if (meta.result === 1 || meta.result === 5) {
                movesHtml += '<span class="pgn-result">' + (meta.winnerColor === 'w' ? '1-0' : '0-1') + '</span>';
            } else if (meta.result >= 2 && meta.result <= 4) {
                movesHtml += '<span class="pgn-result">\u00bd-\u00bd</span>';
            }

            $('#reviewMoves').html(movesHtml);

            // Click handler for moves and board edits (delegate on data-gidx attribute)
            $('#reviewMoves').off('click', '[data-gidx]').on('click', '[data-gidx]', function () {
                const gidx = parseInt($(this).data('gidx'));
                if (!isNaN(gidx)) navigateToMove(gidx);
            });
        }

        function highlightReviewMove() {
            $('#reviewMoves .pgn-move, #reviewMoves .board-edit-marker').removeClass('active');
            if (reviewMoveIndex >= 0) {
                const el = $('#reviewMoves [data-gidx="' + reviewMoveIndex + '"]');
                el.addClass('active');
                if (el[0]) el[0].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }

        // ==========================================
        // Game selector overlay
        // ==========================================

        async function loadGameList() {
            try {
                const resp = await fetch('/games');
                const data = await resp.json();
                return data.games || [];
            } catch (e) {
                console.log('Failed to load game list:', e);
                return [];
            }
        }

        function openGameSelector() {
            loadGameList().then(games => {
                const grid = $('#gameGrid');
                grid.empty();

                if (games.length === 0) {
                    $('#noGamesMsg').show();
                    grid.hide();
                } else {
                    $('#noGamesMsg').hide();
                    grid.show();

                    // Show most recent first
                    games.reverse();

                    games.forEach(game => {
                        const date = formatDate(game.timestamp);
                        const winner = formatWinnerCard(game.winner);

                        let subtitle = MODE_NAMES[game.mode] || 'Game';
                        if (game.mode === 2) {
                            subtitle = 'vs Stockfish (' + (DEPTH_NAMES[game.botDepth] || 'D' + game.botDepth) + ')';
                        }

                        const card = $('<div class=\"game-card\" data-id=\"' + game.id + '\"></div>');
                        card.html(
                            '<span class=\"game-card-check\"><span class=\"check-icon\"></span></span>' +
                            '<div class=\"game-card-date\">' + date + '</div>' +
                            '<div class=\"game-card-mode\">' + subtitle + '</div>' +
                            '<div class=\"game-card-result\">' + winner + '</div>' +
                            '<div class=\"game-card-moves\">' + game.moveCount + ' moves</div>'
                        );
                        grid.append(card);
                    });
                }

                $('#gameSelectorOverlay').addClass('visible');

                // Reset delete mode when opening
                deleteMode = false;
                $('#deleteToggleBtn').removeClass('active');
                $('#gameGrid').removeClass('delete-mode');
                $('.game-card').removeClass('selected-for-delete');
                $('#deleteConfirmBar').hide();
            });
        }

        async function selectGame(gameId) {
            try {
                const resp = await fetch('/games?id=' + gameId);
                if (!resp.ok) {
                    alert('Failed to load game');
                    return;
                }
                const buffer = await resp.arrayBuffer();
                const parsed = parseCompletedGame(buffer);
                const segments = buildGameSegments(parsed);

                // Build metadata for review panel
                const meta = parsed.header;
                meta.gameId = gameId;

                // Close overlay and enter review mode
                $('#gameSelectorOverlay').removeClass('visible');

                // If in edit mode, switch to view mode first
                if (editMode) enableViewMode();

                enterReviewMode(segments, meta);
            } catch (e) {
                console.log('Failed to select game:', e);
                alert('Error loading game data');
            }
        }

        // Helper: create a Chessboard instance with shared config
        function createBoard(position, isEdit) {
            const config = {
                draggable: isEdit,
                position: position,
                pieceTheme: pieceTheme,
                showNotation: settings.showNotation,
                orientation: boardOrientation
            };
            if (isEdit) {
                config.dropOffBoard = 'trash';
                config.sparePieces = true;
                config.onChange = onBoardChange;
            }
            return Chessboard('board', config);
        }

        // Format date in: DD/MM/YYYY HH:MM (24h, no seconds)
        function formatDate(timestamp) {
            if (!timestamp || timestamp <= 0) return 'Unknown date';
            const d = new Date(timestamp * 1000);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            return day + '/' + month + '/' + year + ' ' + hours + ':' + minutes;
        }

        // Helper: format winner text from game metadata (with color square)
        function formatWinner(winnerColor, result) {
            if (winnerColor === 'w') return '<span class="winner-square white-square"></span> White wins';
            if (winnerColor === 'b') return '<span class="winner-square black-square"></span> Black wins';
            if (winnerColor === 'd') return 'Draw';
            return RESULT_NAMES[result] || 'Unknown';
        }

        // Helper: format winner text for game cards (with color square)
        function formatWinnerCard(winnerChar) {
            if (winnerChar === 'w') return '<span class="winner-square white-square"></span> White wins';
            if (winnerChar === 'b') return '<span class="winner-square black-square"></span> Black wins';
            if (winnerChar === 'd') return '\u00bd Draw';
            return '\u2014';
        }

        // Helper: format opponent/mode text from game metadata
        function formatOpponent(meta) {
            if (meta.mode === 2) {
                const diff = DEPTH_NAMES[meta.botDepth] || ('Depth ' + meta.botDepth);
                const color = meta.playerColor === 'w' ? 'White' : 'Black';
                return 'vs Stockfish (' + diff + ') as ' + color;
            }
            return MODE_NAMES[meta.mode] || ('Mode ' + meta.mode);
        }

        // Initialize the board in view mode
        function initBoard() {
            board = createBoard('start', false);
            $(window).on('resize', function () { if (board) board.resize(); });
            applyBoardColors();
        }

        // Switch to edit mode
        function enableEditMode() {
            // Exit review mode if active
            if (reviewMode) exitReviewMode();

            // Restore live position before entering edit mode
            if (liveSegments.length > 0 && !isLive) {
                navLast();
            }

            editMode = true;
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }

            const currentPosition = board.position();

            board.destroy();
            board = createBoard(currentPosition, true);

            applyBoardColors();

            // Prevent page scrolling when dragging pieces on touch devices
            $('#board').on('touchmove', function (e) {
                if ($(e.target).closest('.piece-417db').length) {
                    e.preventDefault();
                }
            });

            $('#modeToggleBtn').text('View Board');
            $('#eval-container').hide();
            if (!settings.instructionsHidden) {
                $('#edit-instructions').addClass('visible');
            }
            $('#fen-section').addClass('visible');

            updateFenDisplay();
        }

        // Switch to view mode
        function enableViewMode() {
            editMode = false;

            const currentPosition = board.position();

            board.destroy();
            board = createBoard(currentPosition, false);

            applyBoardColors();

            $('#board').off('touchmove');

            $('#modeToggleBtn').text('Edit Board');
            $('#eval-container').show();
            $('#edit-instructions').removeClass('visible');
            $('#fen-section').removeClass('visible');

            // Resume polling after short delay to allow things to hide smoothly and
            // To allow the server FEN to be already updated on the first fetch
            setTimeout(() => { startPolling(); }, 250);
        }

        // Board change handler - immediately update FEN display after any board change
        function onBoardChange(oldPos, newPos) {
            // Permanently hide instructions when board is interacted with
            if (!settings.instructionsHidden) {
                settings.instructionsHidden = true;
                $('#edit-instructions').removeClass('visible');
                saveSettings();
            }

            // Play sound for piece movement in edit mode
            const isCapture = detectCapture(oldPos, newPos);
            playMoveSound(isCapture);

            // Detect pawn double moves for en passant
            enPassantSquare = '-';

            // Find what changed between old and new position
            const files = 'abcdefgh';
            for (let f = 0; f < 8; f++) {
                for (let r = 1; r <= 8; r++) {
                    const sq = files[f] + r;
                    const oldPiece = oldPos[sq];
                    const newPiece = newPos[sq];

                    // Check if a pawn appeared on rank 4 (white) or rank 5 (black)
                    if (!oldPiece && newPiece) {
                        // White pawn on rank 4, check if it came from rank 2
                        if (newPiece === 'wP' && r === 4) {
                            const fromSq = files[f] + '2';
                            if (oldPos[fromSq] === 'wP' && !newPos[fromSq]) {
                                enPassantSquare = files[f] + '3';
                            }
                        }
                        // Black pawn on rank 5, check if it came from rank 7
                        if (newPiece === 'bP' && r === 5) {
                            const fromSq = files[f] + '7';
                            if (oldPos[fromSq] === 'bP' && !newPos[fromSq]) {
                                enPassantSquare = files[f] + '6';
                            }
                        }
                    }
                }
            }

            // Use setTimeout to ensure board.fen() returns updated position
            setTimeout(updateFenDisplay, 0);
        }

        // Generate full FEN from board position and game state
        function getFullFen() {
            const positionFen = board.fen();
            const turn = currentTurn;

            let castling = '';
            if (castlingRights.K) castling += 'K';
            if (castlingRights.Q) castling += 'Q';
            if (castlingRights.k) castling += 'k';
            if (castlingRights.q) castling += 'q';
            if (castling === '') castling = '-';

            return positionFen + ' ' + turn + ' ' + castling + ' ' + enPassantSquare + ' ' + halfmoveClock + ' ' + fullmoveNumber;
        }

        // Parse full FEN and update UI state
        function parseFullFen(fen, playSound = true) {
            const parts = fen.trim().split(/\s+/);
            if (parts.length < 1) return false;

            const positionFen = parts[0];

            if (!isValidPositionFen(positionFen)) return false;

            // Get old position before updating
            const oldPosition = board ? board.position() : null;

            board.position(positionFen);

            // Get new position after updating
            const newPosition = board.position();

            // Play sound if position changed and sounds enabled
            if (playSound && oldPosition && previousValidFen !== positionFen) {
                const isCapture = detectCapture(oldPosition, newPosition);
                playMoveSound(isCapture);
            }

            previousValidFen = positionFen;

            if (parts.length >= 2) {
                currentTurn = parts[1] === 'b' ? 'b' : 'w';
                updateTurnButtons();
            }

            if (parts.length >= 3) {
                const castleStr = parts[2];
                castlingRights = {
                    K: castleStr.includes('K'),
                    Q: castleStr.includes('Q'),
                    k: castleStr.includes('k'),
                    q: castleStr.includes('q')
                };
                updateCastlingButtons();
            }

            if (parts.length >= 4) {
                enPassantSquare = parts[3];
            } else {
                enPassantSquare = '-';
            }

            if (parts.length >= 5) {
                halfmoveClock = parseInt(parts[4]) || 0;
            } else {
                halfmoveClock = 0;
            }

            if (parts.length >= 6) {
                fullmoveNumber = parseInt(parts[5]) || 1;
            } else {
                fullmoveNumber = 1;
            }

            updateEnPassantHighlight();
            return true;
        }

        // Validate position FEN (just the board part)
        function isValidPositionFen(fen) {
            if (!fen || typeof fen !== 'string') return false;

            const ranks = fen.split('/');
            if (ranks.length !== 8) return false;

            const validPieces = 'prnbqkPRNBQK';

            for (const rank of ranks) {
                let squares = 0;
                for (const char of rank) {
                    if (char >= '1' && char <= '8') {
                        squares += parseInt(char);
                    } else if (validPieces.includes(char)) {
                        squares += 1;
                    } else {
                        return false;
                    }
                }
                if (squares !== 8) return false;
            }

            return true;
        }

        // Helper function to get piece at a specific square
        function getPieceAt(fen, file, rank) {
            // file: 0-7 (a-h), rank: 0-7 (8-1 in chess notation)
            const ranks = fen.split('/');
            if (rank < 0 || rank > 7) return null;

            const rankStr = ranks[rank];
            let fileIndex = 0;

            for (const char of rankStr) {
                if (char >= '1' && char <= '8') {
                    fileIndex += parseInt(char);
                } else {
                    if (fileIndex === file) return char;
                    fileIndex++;
                }
            }
            return null;
        }

        // Validate chess position is legal (both kings present, valid king count, castling, en passant, etc.)
        function isLegalPosition(fullFen) {
            const parts = fullFen.trim().split(/\s+/);
            if (parts.length < 4) return { valid: false, error: 'Incomplete FEN notation' };

            const fen = parts[0];
            const turn = parts[1];
            const castling = parts[2];
            const enPassant = parts[3];

            if (!isValidPositionFen(fen)) return { valid: false, error: 'Invalid FEN format' };

            const position = fen.split('/').join('');

            // Count pieces
            const whiteKings = (position.match(/K/g) || []).length;
            const blackKings = (position.match(/k/g) || []).length;
            const whiteQueens = (position.match(/Q/g) || []).length;
            const blackQueens = (position.match(/q/g) || []).length;
            const whiteRooks = (position.match(/R/g) || []).length;
            const blackRooks = (position.match(/r/g) || []).length;
            const whiteBishops = (position.match(/B/g) || []).length;
            const blackBishops = (position.match(/b/g) || []).length;
            const whiteKnights = (position.match(/N/g) || []).length;
            const blackKnights = (position.match(/n/g) || []).length;
            const whitePawns = (position.match(/P/g) || []).length;
            const blackPawns = (position.match(/p/g) || []).length;

            // Must have exactly one king per side
            if (whiteKings !== 1) return { valid: false, error: 'White must have exactly one king' };
            if (blackKings !== 1) return { valid: false, error: 'Black must have exactly one king' };

            // Check max pieces (accounting for promotions: 8 pawns can become other pieces)
            if (whiteQueens > 9) return { valid: false, error: 'Too many white queens' };
            if (blackQueens > 9) return { valid: false, error: 'Too many black queens' };
            if (whiteRooks > 10) return { valid: false, error: 'Too many white rooks' };
            if (blackRooks > 10) return { valid: false, error: 'Too many black rooks' };
            if (whiteBishops > 10) return { valid: false, error: 'Too many white bishops' };
            if (blackBishops > 10) return { valid: false, error: 'Too many black bishops' };
            if (whiteKnights > 10) return { valid: false, error: 'Too many white knights' };
            if (blackKnights > 10) return { valid: false, error: 'Too many black knights' };
            if (whitePawns > 8) return { valid: false, error: 'Too many white pawns' };
            if (blackPawns > 8) return { valid: false, error: 'Too many black pawns' };

            // Check total piece count (max 16 per side)
            const whitePieces = whiteKings + whiteQueens + whiteRooks + whiteBishops + whiteKnights + whitePawns;
            const blackPieces = blackKings + blackQueens + blackRooks + blackBishops + blackKnights + blackPawns;
            if (whitePieces > 16) return { valid: false, error: 'Too many white pieces' };
            if (blackPieces > 16) return { valid: false, error: 'Too many black pieces' };

            // Check pawns not on first or last rank
            const ranks = fen.split('/');
            if (ranks[0].match(/[Pp]/) || ranks[7].match(/[Pp]/)) {
                return { valid: false, error: 'Pawns cannot be on the first or last rank' };
            }

            // Validate turn
            if (turn !== 'w' && turn !== 'b') {
                return { valid: false, error: 'Turn must be "w" or "b"' };
            }

            // Validate castling rights
            if (castling !== '-' && !/^[KQkq]{1,4}$/.test(castling)) {
                return { valid: false, error: 'Invalid castling rights format' };
            }

            // Check castling rights consistency with piece positions
            if (castling.includes('K')) {
                // White kingside: King on e1, Rook on h1
                if (getPieceAt(fen, 4, 7) !== 'K') {
                    return { valid: false, error: 'White kingside castling requires king on e1' };
                }
                if (getPieceAt(fen, 7, 7) !== 'R') {
                    return { valid: false, error: 'White kingside castling requires rook on h1' };
                }
            }
            if (castling.includes('Q')) {
                // White queenside: King on e1, Rook on a1
                if (getPieceAt(fen, 4, 7) !== 'K') {
                    return { valid: false, error: 'White queenside castling requires king on e1' };
                }
                if (getPieceAt(fen, 0, 7) !== 'R') {
                    return { valid: false, error: 'White queenside castling requires rook on a1' };
                }
            }
            if (castling.includes('k')) {
                // Black kingside: King on e8, Rook on h8
                if (getPieceAt(fen, 4, 0) !== 'k') {
                    return { valid: false, error: 'Black kingside castling requires king on e8' };
                }
                if (getPieceAt(fen, 7, 0) !== 'r') {
                    return { valid: false, error: 'Black kingside castling requires rook on h8' };
                }
            }
            if (castling.includes('q')) {
                // Black queenside: King on e8, Rook on a8
                if (getPieceAt(fen, 4, 0) !== 'k') {
                    return { valid: false, error: 'Black queenside castling requires king on e8' };
                }
                if (getPieceAt(fen, 0, 0) !== 'r') {
                    return { valid: false, error: 'Black queenside castling requires rook on a8' };
                }
            }

            // Validate en passant square
            if (enPassant !== '-') {
                if (!/^[a-h][36]$/.test(enPassant)) {
                    return { valid: false, error: 'En passant square must be on rank 3 or 6' };
                }

                const file = enPassant.charCodeAt(0) - 'a'.charCodeAt(0);
                const rank = enPassant[1];

                // If en passant is on rank 3, white pawn just moved to rank 4, so it's black's turn
                if (rank === '3') {
                    if (turn !== 'b') {
                        return { valid: false, error: 'En passant on rank 3 requires black to move' };
                    }
                    const pawnPiece = getPieceAt(fen, file, 4); // rank 4 (index 4)
                    if (pawnPiece !== 'P') {
                        return { valid: false, error: 'En passant on rank 3 requires white pawn on rank 4' };
                    }
                }
                // If en passant is on rank 6, black pawn just moved to rank 5, so it's white's turn
                else if (rank === '6') {
                    if (turn !== 'w') {
                        return { valid: false, error: 'En passant on rank 6 requires white to move' };
                    }
                    const pawnPiece = getPieceAt(fen, file, 3); // rank 5 (index 3)
                    if (pawnPiece !== 'p') {
                        return { valid: false, error: 'En passant on rank 6 requires black pawn on rank 5' };
                    }
                }
            }

            return { valid: true, error: null };
        }

        // Update en passant square highlight on the board
        function updateEnPassantHighlight() {
            // Remove any existing highlight
            $('.square-55d63').removeClass('highlight-ep');

            // Only show highlight in edit mode
            if (editMode && enPassantSquare !== '-' && /^[a-h][1-8]$/.test(enPassantSquare)) {
                $('.square-' + enPassantSquare).addClass('highlight-ep');
            }
        }

        // Update FEN input display
        function updateFenDisplay() {
            if (!isEditingFen) {
                $('#fen-input').val(getFullFen());
            }
            updateEnPassantHighlight();
        }

        // Update turn toggle buttons
        function updateTurnButtons() {
            if (currentTurn === 'w') {
                $('#turn-white').addClass('active');
                $('#turn-black').removeClass('active');
            } else {
                $('#turn-white').removeClass('active');
                $('#turn-black').addClass('active');
            }
        }

        // Update castling toggle buttons
        function updateCastlingButtons() {
            ['K', 'Q', 'k', 'q'].forEach(right => {
                if (castlingRights[right]) {
                    $('#castle-' + right).addClass('active');
                } else {
                    $('#castle-' + right).removeClass('active');
                }
            });
        }

        // Update evaluation bar
        function updateEvaluationBar(evalValue) {
            const evalInPawns = evalValue.toFixed(2);
            const maxEval = 10;
            const clampedEval = Math.max(-maxEval, Math.min(maxEval, evalValue));
            const whitePercentage = ((clampedEval + maxEval) / (maxEval * 2)) * 100;

            const bar = document.getElementById('eval-bar');
            const text = document.getElementById('eval-text');

            bar.style.width = whitePercentage + '%';

            let evalText = '';
            let textColor = '#A0A0A0';

            if (evalValue > 0.5) {
                evalText = '+' + evalInPawns;
                textColor = '#000000';
            } else if (evalValue < -0.5) {
                evalText = evalInPawns;
                textColor = '#FFFFFF';
            } else {
                evalText = evalInPawns;
                textColor = '#A0A0A0';
            }

            text.textContent = evalText;
            text.style.color = textColor;
        }

        // Fetch board state from server
        function fetchBoardState() {
            if (editMode || reviewMode) return;

            fetch('/board-update')
                .then(response => response.json())
                .then(data => {
                    if (data.fen) {
                        if (liveSegments.length > 0) {
                            const lastSeg = liveSegments[liveSegments.length - 1];
                            const serverPosFen = data.fen.split(' ')[0];
                            const engineFen = lastSeg.engine.fen().split(' ')[0];
                            if (serverPosFen !== engineFen) {
                                // Try to find a move that leads to this position
                                const legalMoves = lastSeg.engine.moves({ verbose: true });
                                let foundMove = false;
                                for (const m of legalMoves) {
                                    if (m.after.split(' ')[0] === serverPosFen) {
                                        lastSeg.engine.move(m.san);
                                        lastSeg.moveCount = lastSeg.engine.history().length;
                                        computeSegmentOffsets(liveSegments);
                                        totalMoves = computeGlobalTotal(liveSegments);
                                        if (isLive) moveIndex = totalMoves;
                                        foundMove = true;
                                        break;
                                    }
                                }
                                if (!foundMove) {
                                    // Position changed dramatically (board edit) ‚Äî add new segment
                                    try {
                                        const newEngine = new Chess(data.fen);
                                        liveSegments.push({
                                            fen: data.fen,
                                            engine: newEngine,
                                            moveCount: 0,
                                            globalOffset: 0,
                                            span: 0
                                        });
                                        computeSegmentOffsets(liveSegments);
                                        totalMoves = computeGlobalTotal(liveSegments);
                                        moveIndex = totalMoves;
                                        isLive = true;
                                    } catch (e) {
                                        console.log('Failed to create new segment:', e);
                                    }
                                }
                                updateMoveCounter();
                            }
                        } else {
                            // Initialize first segment
                            try {
                                const engine = new Chess(data.fen);
                                liveSegments.push({
                                    fen: data.fen,
                                    engine: engine,
                                    moveCount: 0,
                                    globalOffset: 0,
                                    span: 1
                                });
                                computeSegmentOffsets(liveSegments);
                                totalMoves = computeGlobalTotal(liveSegments);
                                moveIndex = 0;
                                isLive = true;
                                updateMoveCounter();
                            } catch (e) {
                                console.log('Failed to init segments:', e);
                            }
                        }

                        // Only update board display if viewing live position
                        if (isLive) {
                            parseFullFen(data.fen);
                        }
                    }
                    if (data.evaluation !== undefined && isLive) {
                        updateEvaluationBar(data.evaluation);
                    }
                })
                .catch(error => {
                    console.log('Fetch failed:', error);
                });
        }

        // Start polling for updates
        function startPolling() {
            if (updateInterval) clearInterval(updateInterval);
            fetchBoardState();
            updateInterval = setInterval(fetchBoardState, 500);
        }

        // Send edited board to server
        function applyChanges() {
            const fen = getFullFen();

            // Validate position before sending (pass full FEN for complete validation)
            const validation = isLegalPosition(fen);
            if (!validation.valid) {
                alert('Invalid position: ' + validation.error);
                return;
            }

            fetch('/board-update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'fen=' + encodeURIComponent(fen)
            })
                .then(response => {
                    if (response.ok) {
                        enableViewMode();
                    } else {
                        alert('Failed to apply changes. Please try again.');
                    }
                })
                .catch(error => {
                    alert('Network error while applying changes.');
                });
        }

        // Show copy success feedback
        function showCopyFeedback() {
            const btn = $('#fen-copy-btn');
            btn.text('‚úì');
            setTimeout(function () { btn.text('üìã'); }, 1000);
        }

        // Copy FEN to clipboard
        function copyFen() {
            const fenText = $('#fen-input').val();
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(fenText).then(showCopyFeedback).catch(function () {
                    fallbackCopy(fenText);
                });
            } else {
                fallbackCopy(fenText);
            }
        }

        // Fallback copy method
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback();
            } catch (e) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textarea);
        }

        // Toggle FEN editing
        let fenBeforeEdit = '';
        function toggleFenEdit() {
            const fenInput = $('#fen-input');
            const editBtn = $('#fen-edit-btn');

            if (isEditingFen) {
                const newFen = fenInput.val();
                const validation = isLegalPosition(newFen);
                if (!validation.valid || !parseFullFen(newFen, false)) {
                    const errorMsg = validation.error || 'Invalid FEN format';
                    alert('Invalid FEN: ' + errorMsg + '. Reverting to previous position.');
                    parseFullFen(fenBeforeEdit, false);
                }
                isEditingFen = false;
                fenInput.prop('readonly', true);
                editBtn.text('‚úèÔ∏è');
                updateFenDisplay();
            } else {
                fenBeforeEdit = getFullFen();
                isEditingFen = true;
                fenInput.prop('readonly', false);
                fenInput.focus();
                editBtn.text('‚úÖ');
            }
        }

        // Sync board from server
        function syncFromServer() {
            fetch('/board-update')
                .then(response => response.json())
                .then(data => {
                    if (data.fen) {
                        parseFullFen(data.fen, false); // Don't play sound for manual sync
                        updateFenDisplay();
                    }
                })
                .catch(error => {
                    alert('Failed to sync from server.');
                });
        }

        // Event handlers
        $(document).ready(function () {
            loadSettings();
            initBoard();

            // Try to load live game history before starting polling
            loadLiveGame().then(() => {
                startPolling();
            });

            $('#modeToggleBtn').on('click', function () {
                if (editMode) {
                    enableViewMode();
                } else {
                    enableEditMode();
                }
            });

            // Resign button
            $('#resignBtn').on('click', function () {
                if (editMode || reviewMode) return;
                const turn = currentTurn;
                const colorName = turn === 'w' ? 'White' : 'Black';
                if (!confirm(colorName + ' resigns. Are you sure?')) return;
                fetch('/resign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: 'color=' + encodeURIComponent(turn)
                }).then(r => { if (!r.ok) alert('Failed to resign'); })
                    .catch(() => alert('Network error'));
            });

            // Draw button
            $('#drawBtn').on('click', function () {
                if (editMode || reviewMode) return;
                if (!confirm('Agree to a draw?')) return;
                fetch('/draw', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: ''
                }).then(r => { if (!r.ok) alert('Failed to offer draw'); })
                    .catch(() => alert('Network error'));
            });

            $('#turn-white').on('click', function () {
                currentTurn = 'w';
                updateTurnButtons();
                updateFenDisplay();
            });

            $('#turn-black').on('click', function () {
                currentTurn = 'b';
                updateTurnButtons();
                updateFenDisplay();
            });

            ['K', 'Q', 'k', 'q'].forEach(function (right) {
                $('#castle-' + right).on('click', function () {
                    castlingRights[right] = !castlingRights[right];
                    $(this).toggleClass('active');
                    updateFenDisplay();
                });
            });

            $('#sync-btn').on('click', function () {
                syncFromServer();
                playMoveSound(false);
            });

            $('#start-btn').on('click', function () {
                board.start();
                playMoveSound(false);
                currentTurn = 'w';
                castlingRights = { K: true, Q: true, k: true, q: true };
                enPassantSquare = '-';
                halfmoveClock = 0;
                fullmoveNumber = 1;
                updateTurnButtons();
                updateCastlingButtons();
                updateFenDisplay();
            });

            $('#clear-btn').on('click', function () {
                board.clear();
                enPassantSquare = '-';
                halfmoveClock = 0;
                fullmoveNumber = 1;
                updateFenDisplay();
                playMoveSound(false);
            });

            $('#fen-copy-btn').on('click', copyFen);
            $('#fen-edit-btn').on('click', toggleFenEdit);

            $('#fen-input').on('keypress', function (e) {
                if (e.which === 13 && isEditingFen) {
                    toggleFenEdit();
                }
            });

            $('#apply-btn').on('click', applyChanges);

            // Flip board button
            $('#flipBtn').on('click', function () {
                boardOrientation = boardOrientation === 'white' ? 'black' : 'white';
                board.orientation(boardOrientation);
            });

            // Focus mode button
            $('#focusBtn').on('click', function () {
                focusMode = !focusMode;
                $(this).toggleClass('active');
                $('body').toggleClass('focus-mode');
                if (board) {
                    setTimeout(() => board.resize(), 100);
                }
            });

            // Move navigation buttons
            $('#navFirst').on('click', navFirst);
            $('#navPrev').on('click', navPrev);
            $('#navNext').on('click', navNext);
            $('#navLast').on('click', navLast);

            // Keyboard navigation and shortcuts
            $(document).on('keydown', function (e) {
                if (e.key === 'Escape') {
                    if ($('#settingsPopup').hasClass('visible')) {
                        $('#settingsPopup').removeClass('visible');
                    } else if ($('#gameSelectorOverlay').hasClass('visible')) {
                        exitDeleteMode();
                        $('#gameSelectorOverlay').removeClass('visible');
                    } else if (reviewMode) {
                        exitReviewMode();
                    } else if (focusMode) {
                        focusMode = false;
                        $('#focusBtn').removeClass('active');
                        $('body').removeClass('focus-mode');
                        if (board) {
                            setTimeout(() => board.resize(), 100);
                        }
                    }
                    return;
                }
                if (isEditingFen) return;
                if (e.key === 'ArrowLeft') { e.preventDefault(); navPrev(); }
                else if (e.key === 'ArrowRight') { e.preventDefault(); navNext(); }
                else if (e.key === 'Home') { e.preventDefault(); navFirst(); }
                else if (e.key === 'End') { e.preventDefault(); navLast(); }
            });

            // Game selector button
            $('#gameSelectorBtn').on('click', openGameSelector);

            // Close game selector
            $('#closeGameSelector').on('click', function () {
                exitDeleteMode();
                $('#gameSelectorOverlay').removeClass('visible');
            });

            // Close game selector when clicking outside
            $('#gameSelectorOverlay').on('click', function (e) {
                if (e.target === this) {
                    exitDeleteMode();
                    $(this).removeClass('visible');
                }
            });

            // Delete mode state
            let deleteMode = false;

            function exitDeleteMode() {
                deleteMode = false;
                $('#deleteToggleBtn').removeClass('active');
                $('#gameGrid').removeClass('delete-mode');
                $('.game-card').removeClass('selected-for-delete');
                $('#deleteConfirmBar').slideUp(150);
            }

            function updateDeleteConfirmBar() {
                const count = $('.game-card.selected-for-delete').length;
                if (count > 0) {
                    $('#deleteConfirmText').text('Delete ' + count + ' selected game' + (count > 1 ? 's' : '') + '?');
                    $('#deleteConfirmBar').slideDown(150);
                } else {
                    $('#deleteConfirmBar').slideUp(150);
                }
            }

            // Toggle delete mode
            $('#deleteToggleBtn').on('click', function () {
                deleteMode = !deleteMode;
                $(this).toggleClass('active');
                $('#gameGrid').toggleClass('delete-mode', deleteMode);
                if (!deleteMode) {
                    $('.game-card').removeClass('selected-for-delete');
                    $('#deleteConfirmBar').slideUp(150);
                }
            });

            // Game card click handler
            $(document).on('click', '.game-card', function (e) {
                const gameId = $(this).data('id');
                if (deleteMode) {
                    $(this).toggleClass('selected-for-delete');
                    updateDeleteConfirmBar();
                } else {
                    selectGame(gameId);
                }
            });

            $('#deleteConfirmNo').on('click', function () {
                exitDeleteMode();
            });

            $('#deleteConfirmYes').on('click', function () {
                const selected = $('.game-card.selected-for-delete');
                if (selected.length === 0) return;
                const ids = [];
                selected.each(function () { ids.push($(this).data('id')); });

                // Delete all selected games sequentially
                let chain = Promise.resolve();
                ids.forEach(id => {
                    chain = chain.then(() =>
                        fetch('/games?id=' + id, { method: 'DELETE' }).then(resp => {
                            if (!resp.ok) console.log('Failed to delete game ' + id);
                            // If reviewing a deleted game, exit review
                            if (reviewMode && reviewGameMeta && reviewGameMeta.gameId === id) {
                                exitReviewMode();
                            }
                        })
                    );
                });
                chain.then(() => {
                    exitDeleteMode();
                    openGameSelector();
                }).catch(() => alert('Network error while deleting games'));
            });

            // Exit review mode button
            $('#exitReviewBtn').on('click', function () {
                exitReviewMode();
            });

            // Settings button
            $('#settingsBtn').on('click', function () {
                $('#settingsPopup').addClass('visible');
            });

            // Close settings popup
            $('#closeSettings').on('click', function () {
                $('#settingsPopup').removeClass('visible');
            });

            // Close popup when clicking outside
            $('#settingsPopup').on('click', function (e) {
                if (e.target === this) {
                    $(this).removeClass('visible');
                }
            });

            // Settings: Show notation toggle
            $('#settingNotation').on('change', function () {
                settings.showNotation = this.checked;
                saveSettings();
                rebuildBoard();
            });

            // Settings: Play sounds toggle
            $('#settingSound').on('change', function () {
                settings.playSound = this.checked;
                saveSettings();
            });

            // Settings: Light square color
            $('#settingLightColor').on('input', function () {
                settings.lightSquareColor = this.value;
                saveSettings();
            });

            // Settings: Dark square color
            $('#settingDarkColor').on('input', function () {
                settings.darkSquareColor = this.value;
                saveSettings();
            });

            // Reset colors to default
            $('#resetColorsBtn').on('click', function () {
                settings.lightSquareColor = '#f0d9b5';
                settings.darkSquareColor = '#b58863';
                saveSettings();
            });

            // Settings: Piece theme dropdown
            $('#settingPieceTheme').on('change', function () {
                settings.pieceTheme = this.value;
                saveSettings();
                rebuildBoard();
                updateThemeUI();
            });

            // Delete custom piece theme
            $('#deleteThemeBtn').on('click', function () {
                const selectedValue = $('#settingPieceTheme').val();
                if (isCustomTheme(selectedValue)) {
                    if (confirm('Delete this custom theme?')) {
                        settings.customThemes = settings.customThemes.filter(t => t.value !== selectedValue);
                        settings.pieceTheme = defaultThemes[0].value;
                        saveSettings();
                        rebuildBoard();
                    }
                }
            });

            // Add custom piece theme
            $('#addThemeBtn').on('click', function () {
                const themeUrl = prompt('Enter piece theme URL pattern:\n(Use {piece} as placeholder, e.g., https://example.com/pieces/{piece}.png)');
                if (themeUrl && themeUrl.includes('{piece}')) {
                    const themeName = prompt('Enter a name for this theme:');
                    if (themeName) {
                        if (!settings.customThemes) settings.customThemes = [];
                        settings.customThemes.push({ value: themeUrl, label: themeName });
                        settings.pieceTheme = themeUrl;
                        saveSettings();
                        rebuildBoard();
                        updateThemeUI();
                    }
                } else if (themeUrl) {
                    alert('Theme URL must contain {piece} placeholder');
                }
            });
        });

        // Rebuild board with current settings (for notation toggle)
        function rebuildBoard() {
            const currentPosition = board.position();
            board.destroy();
            board = createBoard(currentPosition, editMode);
            applyBoardColors();
        }
    </script>
</body>

</html>