<html lang>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Board</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h2>Chess Board</h2>
        <div class="status" id="board-status">Board state: <span id="state-display" class="state-display-invalid">✗
                Invalid</span></div>
        <div class="board" id="board">
            <!-- Board squares will be generated here -->
        </div>
        <div class="info">
            <div class="eval-bar-container">
                <div id="eval-bar"></div>
                <div id="eval-text">--</div>
            </div>
        </div>
        <a href="/board-edit" class="button">Edit Board</a>
        <a href="/" class="back-button">OpenChess Home</a>
    </div>

    <script>
        let statusHideTimeout;
        let lastValidState = null;

        function generateBoard() {
            const board = document.getElementById("board");
            board.innerHTML = "";
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const isLight = (r + c) % 2 === 0;
                    const squareClass = isLight ? "light" : "dark";
                    const square = document.createElement("div");
                    square.className = `square ${squareClass}`;
                    board.appendChild(square);
                }
            }
        }
        generateBoard();

        // Update evaluation bar with given value
        function updateEvaluationBar(evalValue) {
            const evalInPawns = evalValue.toFixed(2);
            const maxEval = 10;
            const clampedEval = Math.max(-maxEval, Math.min(maxEval, evalValue));

            // Calculate white percentage: at -10 it's 0%, at 0 it's 50%, at 10 it's 100%
            const whitePercentage = ((clampedEval + maxEval) / (maxEval * 2)) * 100;

            const bar = document.getElementById('eval-bar');
            const text = document.getElementById('eval-text');

            // Update bar width for smooth animation
            bar.style.width = whitePercentage + '%';

            let evalText = '';
            let textColor = '#A0A0A0';

            if (evalValue > .5) {
                evalText = '+' + evalInPawns;
                textColor = '#000000';
            } else if (evalValue < -0.5) {
                evalText = evalInPawns;
                textColor = '#FFFFFF';
            } else {
                evalText = evalInPawns;
                textColor = '#A0A0A0';
            }

            text.textContent = evalText;
            text.style.color = textColor;
        }

        // Fetch board state via AJAX for smoother updates
        function updateBoard() {
            fetch('/board').then(response => response.json()).then(data => {
                const stateDisplay = document.getElementById('state-display');
                const statusContainer = document.getElementById('board-status');

                // Only update status display if validity state changed
                if (lastValidState !== data.valid) {
                    lastValidState = data.valid;
                    clearTimeout(statusHideTimeout);

                    if (data.valid) {
                        stateDisplay.style.color = '#4CAF50';
                        stateDisplay.textContent = '✓ Valid';
                        statusContainer.classList.remove('status--hidden');
                        // Force reflow to ensure transition works
                        void statusContainer.offsetHeight;
                        // Fade out after showing valid
                        statusHideTimeout = setTimeout(() => {
                            statusContainer.classList.add('status--hidden');
                        }, 4000);
                    } else {
                        stateDisplay.style.color = '#F44336';
                        stateDisplay.textContent = '✗ Invalid';
                        statusContainer.classList.remove('status--hidden');
                        // Force reflow
                        void statusContainer.offsetHeight;
                    }
                }

                if (data.valid) {
                    const squares = document.querySelectorAll('.square');
                    let index = 0;
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = data.board[row][col];
                            const square = squares[index];
                            if (piece && piece !== '') {
                                const isWhite = piece === piece.toUpperCase();
                                square.innerHTML = '<span class="piece ' + (isWhite ? 'white' : 'black') + '">' + getPieceSymbol(piece) + '</span>';
                            } else {
                                square.innerHTML = '';
                            } index++;
                        }
                    }
                    if (data.evaluation !== undefined)
                        updateEvaluationBar(data.evaluation);
                }
            }).catch(error => {
                console.log('Fetch failed:', error);
            });
        }

        function getPieceSymbol(piece) {
            if (!piece) return '';
            const symbols = { 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟' };
            return symbols[piece.toUpperCase()] || piece;
        }

        updateBoard();
        setInterval(updateBoard, 500);
    </script>
</body>

</html>